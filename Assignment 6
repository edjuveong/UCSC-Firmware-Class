#ifndef __CIRCULAR_BUFFER
#define __CIRCULAR_BUFFER

/* Implement a circularbuffer library with the following API interface */

/**< Circular Buffer Types */
typedef unsigned char INT8U;
typedef INT8U KeyType ;
typedef struct {  
    INT8U writePointer ; /**< write pointer */  
    INT8U readPointer ;  /**< read pointer */  
    INT8U size;         /**< size of circular buffer */
    INT8U mask;         /**< bit Mask of circular buffer size*/   
    KeyType keys[0];    /**< Element of ciruclar buffer */
} CircularBuffer ; 

inline int CircularBufferIsFull(CircularBuffer* que)
{ }
inline int CircularBufferIsEmpty(CircularBuffer* que)
{ }
inline int CircularBufferEnque(CircularBuffer* que, KeyType k)
{ }
inline int CircularBufferDeque(CircularBuffer* que, KeyType* pK)
{ }
inline int CircularBufferPrint(CircularBuffer* que)
{ }

#endif

-------------------------------------------------------------------------

Answer:

Variables:
writePointer – this is the pointer for the write to the circular buffer
readPointer – this is the pointer for the read from the circular buffer
size- this is the size of the buffer
mask – bit mask of circular buffer
keys- element of circular buffer as an array 

Algorithm of circular buffer: Always keep one slot open

This design always keeps one slot unallocated. A full buffer has at most (size-1)slots.
•	If both pointers refer to the same slot, the buffer is empty.
•	If the end (write) pointer refers to the slot preceding the one referred to by the start (read) pointer, the buffer is full.

The advantage is:
•	The solution is simple and robust.

The disadvantages are:
•	One slot is lost, so it is a bad compromise when the buffer size is small or the slot is big or is implemented in hardware.

inline int CircularBufferIsFull(CircularBuffer* que)   

 If the end (write) pointer refers to the slot preceding the one referred to by the start (read) pointer, the buffer is full. 

 int cbIsFull(CircularBuffer *cb) { 

    return (cb->end + 1) % cb->size == cb->start; 
 } 

 
inline int CircularBufferIsEmpty(CircularBuffer* que)   


If both pointers refer to the same slot, the buffer is empty. 


int cbIsEmpty(CircularBuffer *cb) { 

     return cb->end == cb->start; 

 } 


inline int CircularBufferEnque(CircularBuffer* que, KeyType k)
{ }

int cbEnque(CircularBuffer *cb, Q){
 Q[end[Q]]=x; 
 end[Q]=end[Q]+1;
 if (end[Q]==size{
 end[Q]=0;}
 return cb


inline int CircularBufferDeque(CircularBuffer* que, KeyType* pK)
{ }
int cbDeque(CircularBuffer *cb, Q){
 x=Q[start[Q]]; 
 start[Q]=start[Q]+1;
 if (start[Q]==size{
 start[Q]=0;}
 return cb


 inline int CircularBufferPrint(CircularBuffer* que)
{ }
  while (!cbIsEmpty(&cb)) {
        *elem = cb->elems[cb->start];
        cb->start = (cb->start + 1) % cb->size;
        printf("%d\n", elem.value);
    }
 
 
 
