Total Hours Spent: 5.0/1.5
		   Actual/Expect

4357 Embedded Firmware Essentials
- Program Assignment #2

1. Login to mbed web site, export the "Hello World" program to all of the following targets. 
   How many text files and how many lines of text code in the exported offline code package? 
   
   I exported the hello world program that generated the following list of file & folders for the different offline tools:
   
   For  uVision:
   
           .hg (folder/directory)
           mbed (folder/directory)
           .hgignore
           HelloWorld.uvopt
           HelloWorld.uvproj
           main.cpp
           mbed.bld
           
    For GCC ARM Embedded:
    
           .hg (folder/directory)
           mbed (folder/directory)
           .hgignore
           Makefile
           main.cpp
           mbed.bld          
        
   
   uVision - There were two project related files that gives instruction for building: HelloWorld.uvopt and
             HelloWorld.uvproj (project file). Also, in the MBED folder there is a script file LPC1768
             
             There were 200 lines of text code in HelloWorld.uvopt
             There were 423 lines of text code in HelloWorld.uvproj
             
   GCC ARM Embedded - There was only one text file: Makefile (shown below) that is used to give instruction for the build.
   As per below (space in between lines included) there were lines of 56 text code in the make file.  
   
# This file was automagically generated by mbed.org. For more information, 
# see http://mbed.org/handbook/Exporting-to-GCC-ARM-Embedded

GCC_BIN = 
PROJECT = HelloWorld
OBJECTS = ./main.o 
SYS_OBJECTS = ./mbed/LPC1768/GCC_ARM/core_cm3.o ./mbed/LPC1768/GCC_ARM/cmsis_nvic.o ./mbed/LPC1768/GCC_ARM/system_LPC17xx.o ./mbed/LPC1768/GCC_ARM/startup_LPC17xx.o 
INCLUDE_PATHS = -I. -I./mbed -I./mbed/LPC1768 -I./mbed/LPC1768/GCC_ARM 
LIBRARY_PATHS = -L./mbed/LPC1768/GCC_ARM 
LIBRARIES = -lcapi -lmbed 
LINKER_SCRIPT = ./mbed/LPC1768/GCC_ARM/LPC1768.ld

############################################################################### 
AS      = $(GCC_BIN)arm-none-eabi-as
CC      = $(GCC_BIN)arm-none-eabi-gcc
CPP     = $(GCC_BIN)arm-none-eabi-g++
LD      = $(GCC_BIN)arm-none-eabi-gcc
OBJCOPY = $(GCC_BIN)arm-none-eabi-objcopy

CPU = -mcpu=cortex-m3 -mthumb
CC_FLAGS = $(CPU) -c -g -fno-common -fmessage-length=0 -Wall -fno-exceptions -ffunction-sections -fdata-sections 
CC_FLAGS += -MMD -MP
CC_SYMBOLS = -DTARGET_LPC1768 -DTARGET_M3 -DTARGET_NXP -DTARGET_LPC176X -DTARGET_MBED_LPC1768 -DTOOLCHAIN_GCC_ARM -DTOOLCHAIN_GCC -D__CORTEX_M3 -DARM_MATH_CM3 -DMBED_BUILD_TIMESTAMP=1413157701.15 -D__MBED__=1 

LD_FLAGS = -mcpu=cortex-m3 -mthumb -Wl,--gc-sections --specs=nano.specs -u _printf_float -u _scanf_float
LD_SYS_LIBS = -lstdc++ -lsupc++ -lm -lc -lgcc -lnosys

ifeq ($(DEBUG), 1)
  CC_FLAGS += -DDEBUG -O0
else
  CC_FLAGS += -DNDEBUG -Os
endif

all: $(PROJECT).bin

clean:
	rm -f $(PROJECT).bin $(PROJECT).elf $(OBJECTS) $(DEPS)

.s.o:
	$(AS) $(CPU) -o $@ $<

.c.o:
	$(CC)  $(CC_FLAGS) $(CC_SYMBOLS) -std=gnu99   $(INCLUDE_PATHS) -o $@ $<

.cpp.o:
	$(CPP) $(CC_FLAGS) $(CC_SYMBOLS) -std=gnu++98 $(INCLUDE_PATHS) -o $@ $<


$(PROJECT).elf: $(OBJECTS) $(SYS_OBJECTS)
	$(LD) $(LD_FLAGS) -T$(LINKER_SCRIPT) $(LIBRARY_PATHS) -o $@ $^ $(LIBRARIES) $(LD_SYS_LIBS) $(LIBRARIES) $(LD_SYS_LIBS)

$(PROJECT).bin: $(PROJECT).elf
	$(OBJCOPY) -O binary $< $@

DEPS = $(OBJECTS:.o=.d) $(SYS_OBJECTS:.o=.d)
-include $(DEPS)
   
   
   
   How many binary (library or object) files?
   
   uVision-Library path is embed/LPC1768/ARM there were 5 object files (*.0)
   GCC ARM Embedded- Library path is embed/LPC1768/GCC_ARM there were 4 object files (*.o)  
   
   How many files are different between (a) and (b)? (Use linux commands: find, wc, diff) (10 points)
   
   The uVision has more files as compared to GCC ARM. At the main directory, it has HelloWorld.uvopt and
   HelloWorld.uvproj for the instruction build while GCC ARM only has the Makefile
             
   For the library path: uVision has one additional object file called sys.o that was not in GCC ARM
   
   Also, in the library path for uVision it has differnt files called: capi.ar, LPC1768 (windos script), and mbed.ar 
   
   For the library path of GCC ARM it has the different files called: libcapi.a and libmbed.a
   
   What is the "Entry point address:" of your program?  (hint: using readelf) 
   
   Below is the top portion section of result from readelf command for the object file startup_LPC17xx.o in GCC & uvision  
   
   ELF Header:
Magic: 7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 
Class: ELF32
Data: 2's complement, little endian
Version: 1 (current)
OS/ABI: UNIX - System V
ABI Version: 0
Type: REL (Relocatable file)
Machine: ARM
Version: 0x1
Entry point address: 0x0
Start of program headers: 0 (bytes into file)
Start of section headers: 780 (bytes into file)
Flags: 0x5000000, Version5 EABI
Size of this header: 52 (bytes)
Size of program headers: 0 (bytes)
Number of program headers: 0
Size of section headers: 40 (bytes)
Number of section headers: 13
Section header string table index: 10

The entry point address showed is at 0x0 for both the GCC and uVision
 
   uVision- program counter starts at 0000
   GCC ARM Embedded- program counter starts at 0000
   
2. binwalk, objdump, nm to Analysis binaries files
   http://binwalk.org/

 Binwalk is a firmware analysis tool that looks at the header signature.
 It runs in Linux and written in Python.
 
 THe bin file analys of MBED hello world was made using that tool. 
 
3. Optional: git clone https://github.com/mbedmicro/mbed

